"""
依赖漏洞扫描API端点
提供依赖安全扫描和CVE数据库集成
"""

import logging
from typing import List, Dict, Any, Optional
from fastapi import APIRouter, HTTPException, Depends, Query, Body
from pydantic import BaseModel, Field

from app.services.vulnerability_scanner import (
    vulnerability_scanner,
    DependencyInfo,
    Vulnerability,
    SeverityLevel
)
from app.core.auth import get_current_user

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/vulnerability", tags=["vulnerability"])


class ScanRequest(BaseModel):
    """扫描请求"""
    dependencies: List[Dict[str, str]] = Field(..., description="依赖列表")
    ecosystem: str = Field("npm", description="生态系统 (npm, pip, maven)")


class ScanResponse(BaseModel):
    """扫描响应"""
    scan_id: str
    status: str
    total_dependencies: int
    vulnerable_dependencies: int
    vulnerabilities: List[Dict[str, Any]]
    severity_distribution: Dict[str, int]
    recommendations: List[str]
    scan_time: str


class VulnerabilityDetailRequest(BaseModel):
    """漏洞详情请求"""
    cve_id: str = Field(..., description="CVE ID")


class VulnerabilityDetailResponse(BaseModel):
    """漏洞详情响应"""
    cve_id: str
    vulnerability: Optional[Dict[str, Any]]
    error: Optional[str] = None


@router.post("/scan", response_model=ScanResponse)
async def scan_dependencies(
    request: ScanRequest,
    current_user: Dict = Depends(get_current_user)
):
    """扫描依赖漏洞"""
    try:
        # 转换依赖信息
        dependencies_info = []
        for dep in request.dependencies:
            if isinstance(dep, dict):
                dependencies_info.append(DependencyInfo(
                    name=dep.get("name", ""),
                    version=dep.get("version", ""),
                    ecosystem=request.ecosystem
                ))
            else:
                # 假设格式为 {"name": "version"}
                if ":" in dep:
                    name, version = dep.split(":", 1)
                else:
                    name, version = dep, ""
                dependencies_info.append(DependencyInfo(
                    name=name,
                    version=version,
                    ecosystem=request.ecosystem
                ))
        
        # 执行扫描
        scan_results = await vulnerability_scanner.scan_dependencies(
            dependencies_info, request.ecosystem
        )
        
        # 生成扫描ID
        scan_id = f"scan_{int(scan_results['scan_time'].replace(':', '').replace('-', '')}"
        
        return ScanResponse(
            scan_id=scan_id,
            status="completed",
            total_dependencies=scan_results["total_dependencies"],
            vulnerable_dependencies=scan_results["vulnerable_dependencies"],
            vulnerabilities=[
                {
                    "cve_id": vuln.cve_id,
                    "package_name": vuln.package_name,
                    "package_version": vuln.package_version,
                    "severity": vuln.severity.value,
                    "title": vuln.title,
                    "description": vuln.description,
                    "published_date": vuln.published_date,
                    "modified_date": vuln.modified_date,
                    "cvss_score": vuln.cvss_score,
                    "references": vuln.references
                }
                for vuln in scan_results["vulnerabilities"]
            ],
            severity_distribution=scan_results["severity_distribution"],
            recommendations=scan_results["recommendations"],
            scan_time=scan_results["scan_time"]
        )
        
    except Exception as e:
        logger.error(f"Error scanning dependencies: {e}")
        raise HTTPException(status_code=500, detail=f"扫描失败: {str(e)}")


@router.get("/scan/{scan_id}/vulnerabilities", response_model=List[Dict[str, Any]])
async def get_scan_vulnerabilities(
    scan_id: str,
    current_user: Dict = Depends(get_current_user)
):
    """获取扫描结果中的漏洞列表"""
    try:
        # 从缓存或数据库获取扫描结果
        # 这里简化实现，实际应该从数据库查询
        return []
        
    except Exception as e:
        logger.error(f"Error getting scan vulnerabilities: {e}")
        raise HTTPException(status_code=500, detail=f"获取漏洞列表失败: {str(e)}")


@router.get("/vulnerability/{cve_id}", response_model=VulnerabilityDetailResponse)
async def get_vulnerability_details(
    cve_id: str,
    current_user: Dict = Depends(get_current_user)
):
    """获取漏洞详细信息"""
    try:
        # 获取漏洞详情
        vulnerability = await vulnerability_scanner.get_vulnerability_details(cve_id)
        
        if vulnerability:
            return VulnerabilityDetailResponse(
                cve_id=cve_id,
                vulnerability={
                    "cve_id": vulnerability.cve_id,
                    "package_name": vulnerability.package_name,
                    "package_version": vulnerability.package_version,
                    "severity": vulnerability.severity.value,
                    "title": vulnerability.title,
                    "description": vulnerability.description,
                    "references": vulnerability.references,
                    "published_date": vulnerability.published_date,
                    "modified_date": vulnerability.modified_date,
                    "cvss_score": vulnerability.cvss_score,
                    "cvss_vector": vulnerability.cvss_vector,
                    "metadata": vulnerability.metadata
                }
            )
        else:
            return VulnerabilityDetailResponse(
                cve_id=cve_id,
                error="Vulnerability not found"
            )
        
    except Exception as e:
        logger.error(f"Error getting vulnerability details: {e}")
        raise HTTPException(status_code=500, detail=f"获取漏洞详情失败: {str(e)}")


@router.get("/stats", response_model=Dict[str, Any])
async def get_vulnerability_stats(
    current_user: Dict = Depends(get_current_user)
):
    """获取漏洞统计信息"""
    try:
        # 获取缓存统计
        cache_stats = vulnerability_scanner.get_cache_stats()
        
        # 模拟统计数据（实际应该从数据库聚合）
        stats = {
            "cache_stats": cache_stats,
            "total_scans": 0,
            "total_vulnerabilities": 0,
            "severity_distribution": {
                "critical": 0,
                "high": 0,
                "medium": 0,
                "low": 0,
                "info": 0
            },
            "top_vulnerable_packages": [],
            "recent_scans": []
        }
        
        return stats
        
    except Exception as e:
        logger.error(f"Error getting vulnerability stats: {e}")
        raise HTTPException(status_code=500, detail=f"获取统计信息失败: {str(e)}")


@router.post("/cache/clear", response_model=Dict[str, Any])
async def clear_vulnerability_cache(
    current_user: Dict = Depends(get_current_user)
):
    """清空漏洞缓存"""
    try:
        vulnerability_scanner.clear_cache()
        
        return {
            "message": "Vulnerability cache cleared successfully",
            "cache_stats": vulnerability_scanner.get_cache_stats()
        }
        
    except Exception as e:
        logger.error(f"Error clearing vulnerability cache: {e}")
        raise HTTPException(status_code=500, detail=f"清空缓存失败: {str(e)}")


@router.get("/cve/search", response_model=List[Dict[str, Any]])
async def search_cves(
    q: str = Query(..., description="搜索关键词"),
    severity: Optional[str] = Query(None, description="严重程度过滤"),
    limit: int = Query(20, ge=1, le=100, description="结果限制"),
    current_user: Dict = Depends(get_current_user)
):
    """搜索CVE"""
    try:
        # 这里简化实现，实际应该调用CVE搜索API
        # 模拟搜索结果
        search_results = []
        
        if q:
            # 模拟搜索逻辑
            search_results = [
                {
                    "cve_id": "CVE-2023-1234",
                    "title": f"Example vulnerability related to {q}",
                    "severity": "high",
                    "published_date": "2023-12-01"
                }
            ]
        
        return search_results
        
    except Exception as e:
        logger.error(f"Error searching CVEs: {e}")
        raise HTTPException(status_code=500, detail=f"搜索CVE失败: {str(e)}")


@router.get("/package/{package_name}/vulnerabilities", response_model=List[Dict[str, Any]])
async def get_package_vulnerabilities(
    package_name: str,
    ecosystem: str = Query("npm", description="生态系统"),
    current_user: Dict = Depends(get_current_user)
):
    """获取特定包的漏洞列表"""
    try:
        # 这里简化实现，实际应该查询数据库
        # 模拟包漏洞数据
        package_vulns = [
            {
                "cve_id": "CVE-2023-5678",
                "package_name": package_name,
                "package_version": "1.0.0",
                "severity": "medium",
                "title": f"Vulnerability in {package_name}",
                "description": "Example vulnerability description"
            }
        ]
        
        return package_vulns
        
    except Exception as e:
        logger.error(f"Error getting package vulnerabilities: {e}")
        raise HTTPException(status_code=500, detail=f"获取包漏洞失败: {str(e)}")


@router.get("/dashboard", response_model=Dict[str, Any])
async def get_vulnerability_dashboard(
    current_user: Dict = Depends(get_current_user)
):
    """获取漏洞仪表板数据"""
    try:
        # 获取仪表板数据
        dashboard_data = {
            "summary": {
                "total_vulnerabilities": 0,
                "critical_vulnerabilities": 0,
                "high_vulnerabilities": 0,
                "medium_vulnerabilities": 0,
                "low_vulnerabilities": 0,
                "vulnerability_trend": []
            },
            "top_vulnerable_packages": [],
            "recent_vulnerabilities": [],
            "severity_chart": {
                "critical": 0,
                "high": 0,
                "medium": 0,
                "low": 0,
                "info": 0
            },
            "ecosystem_distribution": {
                "npm": 0,
                "pip": 0,
                "maven": 0
            }
        }
        
        return dashboard_data
        
    except Exception as e:
        logger.error(f"Error getting dashboard data: {e}")
        raise HTTPException(status_code=500, detail=f"获取仪表板数据失败: {str(e)}")