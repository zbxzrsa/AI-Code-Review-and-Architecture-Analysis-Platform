"""
依赖漏洞扫描服务
集成CVE数据库，扫描项目依赖中的已知漏洞
"""

import asyncio
import json
import logging
from typing import Dict, List, Optional, Any, Set
from dataclasses import dataclass, asdict
from datetime import datetime, timedelta
from enum import Enum
import aiohttp
import re
from pathlib import Path

logger = logging.getLogger(__name__)


class SeverityLevel(Enum):
    """漏洞严重程度"""
    CRITICAL = "critical"  # 严重漏洞，需要立即修复
    HIGH = "high"         # 高危漏洞，建议尽快修复
    MEDIUM = "medium"       # 中危漏洞，建议修复
    LOW = "low"           # 低危漏洞，可选修复
    INFO = "info"         # 信息性，仅供参考


@dataclass
class Vulnerability:
    """漏洞信息"""
    cve_id: str
    package_name: str
    package_version: str
    severity: SeverityLevel
    title: str
    description: str
    references: List[str]
    published_date: str
    modified_date: str
    cvss_score: Optional[float] = None
    cvss_vector: Optional[str] = None
    affected_versions: List[str] = None
    patched_versions: List[str] = None
    solution: Optional[str] = None
    metadata: Dict[str, Any] = None


@dataclass
class DependencyInfo:
    """依赖信息"""
    name: str
    version: str
    ecosystem: str  # npm, pip, maven, etc.
    license: Optional[str] = None
    homepage: Optional[str] = None
    repository: Optional[str] = None
    vulnerabilities: List[Vulnerability] = None


class VulnerabilityScanner:
    """漏洞扫描器"""
    
    def __init__(self, cache_ttl: int = 3600):
        self.cache_ttl = cache_ttl
        self.cache: Dict[str, Any] = {}
        self.cache_timestamps: Dict[str, datetime] = {}
        
        # CVE 数据源
        self.cve_sources = [
            "https://services.nvd.nist.gov/rest/json/cves/1.0",
            "https://api.github.com/advisories",
            "https://ossindex.net/api/v3/package"
        ]
    
    async def scan_dependencies(
        self,
        dependencies: List[DependencyInfo],
        ecosystem: str = "npm"
    ) -> Dict[str, Any]:
        """扫描依赖漏洞"""
        logger.info(f"Scanning {len(dependencies)} dependencies for {ecosystem} ecosystem")
        
        results = {
            "scan_time": datetime.utcnow().isoformat(),
            "ecosystem": ecosystem,
            "total_dependencies": len(dependencies),
            "vulnerable_dependencies": 0,
            "vulnerabilities": [],
            "severity_distribution": {
                "critical": 0,
                "high": 0,
                "medium": 0,
                "low": 0,
                "info": 0
            },
            "recommendations": []
        }
        
        # 并发扫描所有依赖
        tasks = []
        for dep in dependencies:
            task = asyncio.create_task(
                self._scan_single_dependency(dep, ecosystem)
            )
            tasks.append(task)
        
        # 等待所有扫描完成
        scan_results = await asyncio.gather(*tasks, return_exceptions=True)
        
        # 处理结果
        for i, result in enumerate(scan_results):
            if isinstance(result, Exception):
                logger.error(f"Error scanning dependency {dependencies[i].name}: {result}")
                continue
            
            dep_name, vulnerabilities = result
            if vulnerabilities:
                results["vulnerable_dependencies"] += 1
                results["vulnerabilities"].extend(vulnerabilities)
                
                # 更新严重程度分布
                for vuln in vulnerabilities:
                    severity = vuln.severity.value
                    if severity in results["severity_distribution"]:
                        results["severity_distribution"][severity] += 1
        
        # 生成建议
        results["recommendations"] = self._generate_recommendations(results)
        
        return results
    
    async def _scan_single_dependency(
        self,
        dependency: DependencyInfo,
        ecosystem: str
    ) -> tuple[str, List[Vulnerability]]:
        """扫描单个依赖"""
        cache_key = f"{ecosystem}:{dependency.name}:{dependency.version}"
        
        # 检查缓存
        if self._is_cache_valid(cache_key):
            cached_result = self.cache.get(cache_key)
            if cached_result:
                logger.debug(f"Using cached result for {dependency.name}")
                return dependency.name, cached_result
        
        vulnerabilities = []
        
        try:
            # 根据生态系统选择扫描方法
            if ecosystem == "npm":
                vulnerabilities = await self._scan_npm_dependency(dependency)
            elif ecosystem == "pip":
                vulnerabilities = await self._scan_pip_dependency(dependency)
            elif ecosystem == "maven":
                vulnerabilities = await self._scan_maven_dependency(dependency)
            else:
                logger.warning(f"Unsupported ecosystem: {ecosystem}")
            
            # 缓存结果
            self.cache[cache_key] = vulnerabilities
            self.cache_timestamps[cache_key] = datetime.utcnow()
            
        except Exception as e:
            logger.error(f"Error scanning {dependency.name}: {e}")
        
        return dependency.name, vulnerabilities
    
    async def _scan_npm_dependency(self, dependency: DependencyInfo) -> List[Vulnerability]:
        """扫描 npm 依赖"""
        vulnerabilities = []
        
        # 使用 OSV-Dev API
        try:
            url = f"https://api.osv.dev/v1/query?package={dependency.name}&version={dependency.version}"
            
            async with aiohttp.ClientSession() as session:
                async with session.get(url, timeout=aiohttp.ClientTimeout(total=10)) as response:
                    if response.status == 200:
                        data = await response.json()
                        
                        if data.get("vulns"):
                            for vuln_data in data["vulns"]:
                                vuln = self._parse_osv_vulnerability(vuln_data, dependency)
                                if vuln:
                                    vulnerabilities.append(vuln)
        
        except Exception as e:
            logger.error(f"Error querying OSV-Dev for {dependency.name}: {e}")
        
        # 使用 GitHub Advisory 作为备用
        if not vulnerabilities:
            try:
                url = f"https://api.github.com/advisories?package={dependency.name}&ecosystem=npm"
                
                async with aiohttp.ClientSession() as session:
                    async with session.get(url, timeout=aiohttp.ClientTimeout(total=10)) as response:
                        if response.status == 200:
                            data = await response.json()
                            
                            for advisory in data:
                                if self._is_version_affected(dependency.version, advisory):
                                    vuln = self._parse_github_advisory(advisory, dependency)
                                    if vuln:
                                        vulnerabilities.append(vuln)
            
            except Exception as e:
                logger.error(f"Error querying GitHub Advisory for {dependency.name}: {e}")
        
        return vulnerabilities
    
    async def _scan_pip_dependency(self, dependency: DependencyInfo) -> List[Vulnerability]:
        """扫描 pip 依赖"""
        vulnerabilities = []
        
        # 使用 OSV-Dev API for Python
        try:
            url = f"https://api.osv.dev/v1/query?package={dependency.name}&version={dependency.version}&ecosystem=PyPI"
            
            async with aiohttp.ClientSession() as session:
                async with session.get(url, timeout=aiohttp.ClientTimeout(total=10)) as response:
                    if response.status == 200:
                        data = await response.json()
                        
                        if data.get("vulns"):
                            for vuln_data in data["vulns"]:
                                vuln = self._parse_osv_vulnerability(vuln_data, dependency)
                                if vuln:
                                    vulnerabilities.append(vuln)
        
        except Exception as e:
            logger.error(f"Error querying OSV-Dev for Python package {dependency.name}: {e}")
        
        return vulnerabilities
    
    async def _scan_maven_dependency(self, dependency: DependencyInfo) -> List[Vulnerability]:
        """扫描 Maven 依赖"""
        vulnerabilities = []
        
        # 使用 OSV-Dev API for Maven
        try:
            url = f"https://api.osv.dev/v1/query?package={dependency.name}&version={dependency.version}&ecosystem=Maven"
            
            async with aiohttp.ClientSession() as session:
                async with session.get(url, timeout=aiohttp.ClientTimeout(total=10)) as response:
                    if response.status == 200:
                        data = await response.json()
                        
                        if data.get("vulns"):
                            for vuln_data in data["vulns"]:
                                vuln = self._parse_osv_vulnerability(vuln_data, dependency)
                                if vuln:
                                    vulnerabilities.append(vuln)
        
        except Exception as e:
            logger.error(f"Error querying OSV-Dev for Maven package {dependency.name}: {e}")
        
        return vulnerabilities
    
    def _parse_osv_vulnerability(self, vuln_data: Dict[str, Any], dependency: DependencyInfo) -> Optional[Vulnerability]:
        """解析 OSV 漏洞数据"""
        try:
            # 提取 CVE ID
            cve_id = vuln_data.get("id", "")
            
            # 提取严重程度
            severity_str = vuln_data.get("severity", "UNKNOWN").upper()
            severity = SeverityLevel.MEDIUM
            if severity_str in [s.value for s in SeverityLevel]:
                severity = SeverityLevel(severity_str)
            
            # 提取 CVSS 分数
            cvss_score = vuln_data.get("database_specific", {}).get("nvd", {}).get("cvss_v3", {}).get("base_score")
            
            # 提取描述
            summary = vuln_data.get("summary", "")
            details = vuln_data("details", "")
            description = summary if summary else details
            
            # 提取引用
            references = []
            for ref in vuln_data.get("references", []):
                if ref.get("url"):
                    references.append(ref["url"])
            
            # 提取时间信息
            published = vuln_data.get("published", "")
            modified = vuln_data.get("modified", "")
            
            # 提取受影响版本
            affected = []
            for affected_item in vuln_data.get("affected", []):
                for version_range in affected_item.get("versions", []):
                    affected.append(version_range)
            
            return Vulnerability(
                cve_id=cve_id,
                package_name=dependency.name,
                package_version=dependency.version,
                severity=severity,
                title=summary,
                description=description,
                references=references,
                published_date=published,
                modified_date=modified,
                cvss_score=cvss_score,
                affected_versions=affected,
                metadata=vuln_data
            )
            
        except Exception as e:
            logger.error(f"Error parsing OSV vulnerability: {e}")
            return None
    
    def _parse_github_advisory(self, advisory: Dict[str, Any], dependency: DependencyInfo) -> Optional[Vulnerability]:
        """解析 GitHub Advisory"""
        try:
            # 提取 CVE ID
            cve_id = advisory.get("cve_id", "")
            if not cve_id:
                cve_id = f"GHSA-{advisory.get('ghsa_id', '')}"
            
            # 提取严重程度
            severity_str = advisory.get("severity", "moderate").upper()
            severity = SeverityLevel.MEDIUM
            if severity_str in [s.value for s in SeverityLevel]:
                severity = SeverityLevel(severity_str)
            
            # 提取描述
            summary = advisory.get("summary", "")
            description = summary
            
            # 提取引用
            references = []
            if advisory.get("html_url"):
                references.append(advisory["html_url"])
            
            # 提取时间信息
            published = advisory.get("published_at", "")
            modified = advisory.get("updated_at", "")
            
            # 提取受影响版本
            affected = []
            for affected_item in advisory.get("vulnerabilities", []):
                for pkg in affected_item.get("package", []):
                    if pkg.get("name") == dependency.name:
                        affected.extend(pkg.get("versions", []))
            
            return Vulnerability(
                cve_id=cve_id,
                package_name=dependency.name,
                package_version=dependency.version,
                severity=severity,
                title=summary,
                description=description,
                references=references,
                published_date=published,
                modified_date=modified,
                affected_versions=affected,
                metadata=advisory
            )
            
        except Exception as e:
            logger.error(f"Error parsing GitHub Advisory: {e}")
            return None
    
    def _is_version_affected(self, version: str, advisory: Dict[str, Any]) -> bool:
        """检查版本是否受影响"""
        try:
            # 简化的版本比较逻辑
            affected_versions = []
            for vuln in advisory.get("vulnerabilities", []):
                for pkg in vuln.get("package", []):
                    if pkg.get("name") == version.split("@")[0]:
                        affected_versions.extend(pkg.get("versions", []))
            
            # 检查版本是否在受影响列表中
            for affected_range in affected_versions:
                if self._version_in_range(version, affected_range):
                    return True
            
            return False
            
        except Exception:
            return False
    
    def _version_in_range(self, version: str, version_range: str) -> bool:
        """检查版本是否在版本范围内"""
        # 简化实现，实际应该使用 semver 库
        try:
            # 移除版本前缀
            clean_version = version.lstrip("vV")
            clean_range = version_range.lstrip("vV")
            
            # 处理范围表达式
            if "<=" in clean_range:
                max_version = clean_range.split("<=")[1].strip()
                return self._compare_versions(clean_version, max_version) <= 0
            elif "<" in clean_range:
                max_version = clean_range.split("<")[1].strip()
                return self._compare_versions(clean_version, max_version) < 0
            elif ">=" in clean_range:
                min_version = clean_range.split(">=")[1].strip()
                return self._compare_versions(clean_version, min_version) >= 0
            elif ">" in clean_range:
                min_version = clean_range.split(">")[1].strip()
                return self._compare_versions(clean_version, min_version) > 0
            elif "==" in clean_range:
                target_version = clean_range.split("==")[1].strip()
                return clean_version == target_version
            
            return False
            
        except Exception:
            return False
    
    def _compare_versions(self, v1: str, v2: str) -> int:
        """比较版本号"""
        try:
            # 简化的版本比较
            v1_parts = [int(x) for x in re.findall(r'\d+', v1)]
            v2_parts = [int(x) for x in re.findall(r'\d+', v2)]
            
            # 补齐版本号长度
            max_len = max(len(v1_parts), len(v2_parts))
            v1_parts.extend([0] * (max_len - len(v1_parts)))
            v2_parts.extend([0] * (max_len - len(v2_parts)))
            
            # 逐位比较
            for i in range(max_len):
                if v1_parts[i] < v2_parts[i]:
                    return -1
                elif v1_parts[i] > v2_parts[i]:
                    return 1
            
            return 0
            
        except Exception:
            return 0
    
    def _is_cache_valid(self, cache_key: str) -> bool:
        """检查缓存是否有效"""
        if cache_key not in self.cache_timestamps:
            return False
        
        age = datetime.utcnow() - self.cache_timestamps[cache_key]
        return age.total_seconds() < self.cache_ttl
    
    def _generate_recommendations(self, scan_results: Dict[str, Any]) -> List[str]:
        """生成修复建议"""
        recommendations = []
        
        # 基于严重程度分布生成建议
        severity_dist = scan_results["severity_distribution"]
        
        if severity_dist["critical"] > 0:
            recommendations.append(
                f"发现 {severity_dist['critical']} 个严重漏洞，建议立即修复"
            )
        
        if severity_dist["high"] > 0:
            recommendations.append(
                f"发现 {severity_dist['high']} 个高危漏洞，建议尽快修复"
            )
        
        if severity_dist["medium"] > 5:
            recommendations.append(
                f"发现 {severity_dist['medium']} 个中危漏洞，建议制定修复计划"
            )
        
        # 基于漏洞数量生成建议
        total_vulns = scan_results["vulnerable_dependencies"]
        total_deps = scan_results["total_dependencies"]
        
        if total_vulns > 0:
            vuln_ratio = (total_vulns / total_deps) * 100
            if vuln_ratio > 20:
                recommendations.append(
                    f"漏洞依赖比例较高 ({vuln_ratio:.1f}%)，建议全面审查依赖"
                )
        
        # 通用建议
        recommendations.extend([
            "定期更新依赖到最新稳定版本",
            "使用自动化工具监控依赖安全",
            "建立依赖安全审查流程",
            "考虑使用依赖锁定文件防止供应链攻击"
        ])
        
        return recommendations
    
    async def get_vulnerability_details(
        self,
        cve_id: str
    ) -> Optional[Vulnerability]:
        """获取漏洞详细信息"""
        # 检查缓存
        cache_key = f"cve:{cve_id}"
        if self._is_cache_valid(cache_key):
            return self.cache.get(cache_key)
        
        try:
            # 从 NVD 获取详细信息
            url = f"https://services.nvd.nist.gov/rest/json/cves/1.0/{cve_id}"
            
            async with aiohttp.ClientSession() as session:
                async with session.get(url, timeout=aiohttp.ClientTimeout(total=15)) as response:
                    if response.status == 200:
                        data = await response.json()
                        
                        cve_data = data.get("result", {}).get("CVE_Items", [{}])[0]
                        
                        vulnerability = Vulnerability(
                            cve_id=cve_id,
                            package_name=cve_data.get("vendor", ""),
                            package_version="",
                            severity=self._parse_nvd_severity(cve_data.get("impact", {}).get("baseMetricV3", "UNKNOWN")),
                            title=cve_data.get("cve", {}).get("description", ""),
                            description=cve_data.get("cve", {}).get("description", ""),
                            references=[],
                            published_date=cve_data.get("publishedDate", ""),
                            modified_date=cve_data.get("lastModifiedDate", ""),
                            cvss_score=cve_data.get("impact", {}).get("baseMetricV3", {}).get("cvssV3", {}).get("baseScore"),
                            cvss_vector=cve_data.get("impact", {}).get("baseMetricV3", {}).get("cvssV3", {}).get("vectorString"),
                            metadata=cve_data
                        )
                        
                        # 缓存结果
                        self.cache[cache_key] = vulnerability
                        self.cache_timestamps[cache_key] = datetime.utcnow()
                        
                        return vulnerability
        
        except Exception as e:
            logger.error(f"Error fetching CVE details for {cve_id}: {e}")
        
        return None
    
    def _parse_nvd_severity(self, impact_data: Dict[str, Any]) -> SeverityLevel:
        """解析 NVD 严重程度"""
        base_severity = impact_data.get("baseSeverity", "UNKNOWN").upper()
        
        severity_map = {
            "CRITICAL": SeverityLevel.CRITICAL,
            "HIGH": SeverityLevel.HIGH,
            "MEDIUM": SeverityLevel.MEDIUM,
            "LOW": SeverityLevel.LOW,
            "INFO": SeverityLevel.INFO
        }
        
        return severity_map.get(base_severity, SeverityLevel.MEDIUM)
    
    def clear_cache(self):
        """清空缓存"""
        self.cache.clear()
        self.cache_timestamps.clear()
        logger.info("Vulnerability scan cache cleared")
    
    def get_cache_stats(self) -> Dict[str, Any]:
        """获取缓存统计"""
        return {
            "cache_size": len(self.cache),
            "cache_keys": list(self.cache.keys()),
            "cache_timestamps": {
                key: timestamp.isoformat() 
                for key, timestamp in self.cache_timestamps.items()
            }
        }


# 全局实例
vulnerability_scanner = VulnerabilityScanner()